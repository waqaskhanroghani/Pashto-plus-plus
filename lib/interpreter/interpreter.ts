/**
 * Interpreter for Pashto++ programming language
 * Executes the AST generated by the parser
 */

import { Node, NodeType, Program, Statement, Expression, NumericLiteral, StringLiteral, BooleanLiteral, Identifier, BinaryExpression, AssignmentExpression, CallExpression, ReturnStatement, IfStatement, WhileStatement, ForStatement, BlockStatement, ExpressionStatement, ArrayLiteral, FunctionDeclaration } from './parser';

// Environment for storing variables and functions
class Environment {
  private values: Map<string, any>;
  private parent: Environment | null;

  constructor(parent: Environment | null = null) {
    this.values = new Map();
    this.parent = parent;
  }

  define(name: string, value: any): void {
    this.values.set(name, value);
  }

  assign(name: string, value: any): void {
    if (this.values.has(name)) {
      this.values.set(name, value);
      return;
    }

    if (this.parent) {
      this.parent.assign(name, value);
      return;
    }

    throw new Error(`Cannot assign to undefined variable '${name}'`);
  }

  get(name: string): any {
    if (this.values.has(name)) {
      return this.values.get(name);
    }

    if (this.parent) {
      return this.parent.get(name);
    }

    throw new Error(`Undefined variable '${name}'`);
  }

  has(name: string): boolean {
    if (this.values.has(name)) {
      return true;
    }

    if (this.parent) {
      return this.parent.has(name);
    }

    return false;
  }
}

// Function object for user-defined functions
class PashtoPlusPlusFunction {
  private declaration: FunctionDeclaration;
  private closure: Environment;

  constructor(declaration: FunctionDeclaration, closure: Environment) {
    this.declaration = declaration;
    this.closure = closure;
  }

  call(interpreter: Interpreter, args: any[]): any {
    const environment = new Environment(this.closure);

    // Define parameters in the function's environment
    for (let i = 0; i < this.declaration.params.length; i++) {
      environment.define(this.declaration.params[i], args[i]);
    }

    try {
      // Execute the function body
      interpreter.executeBlock(this.declaration.body.body, environment);
    } catch (returnValue) {
      if (returnValue instanceof ReturnValue) {
        return returnValue.value;
      }
      throw returnValue;
    }

    return null;
  }
}

// Helper class for handling return statements
class ReturnValue {
  value: any;

  constructor(value: any) {
    this.value = value;
  }
}

// The main interpreter class
export class Interpreter {
  private environment: Environment;
  private globals: Environment;
  private output: string[] = [];
  private inputCallback: () => Promise<string>;

  constructor(inputCallback: () => Promise<string>) {
    this.globals = new Environment();
    this.environment = this.globals;
    this.inputCallback = inputCallback;

    // Define built-in functions
    this.defineBuiltins();
  }

  private defineBuiltins(): void {
    // olika (print) function
    this.globals.define('olika', (...args: any[]) => {
      const output = args.map(arg => this.stringify(arg)).join(' ');
      this.output.push(output);
      return null;
    });

    // oghwara (input) function
    this.globals.define('oghwara', async (prompt: string) => {
      this.output.push(prompt); // Show the prompt
      const input = await this.inputCallback();
      return input;
    });

    // jorkanumbers (range) function
    this.globals.define('jorkanumbers', (start: number, end: number) => {
      const result = [];
      for (let i = start; i < end; i++) {
        result.push(i);
      }
      return result;
    });

    // oshmara (length) function
    this.globals.define('oshmara', (array: any[]) => {
      if (!Array.isArray(array)) {
        throw new Error('oshmara expects an array');
      }
      return array.length;
    });

    // max function
    this.globals.define('max', (...args: number[]) => {
      if (args.length === 0) {
        throw new Error('max requires at least one argument');
      }
      return Math.max(...args);
    });

    // min function
    this.globals.define('min', (...args: number[]) => {
      if (args.length === 0) {
        throw new Error('min requires at least one argument');
      }
      return Math.min(...args);
    });

    // abs function
    this.globals.define('abs', (num: number) => {
      if (typeof num !== 'number') {
        throw new Error('abs requires a number argument');
      }
      return Math.abs(num);
    });
  }

  // Convert values to string for output
  private stringify(value: any): string {
    if (value === null) return 'null';
    if (typeof value === 'boolean') {
      return value ? 'rishtia' : 'ghalat';
    }
    if (Array.isArray(value)) {
      return '[' + value.map(v => this.stringify(v)).join(', ') + ']';
    }
    return String(value);
  }

  // Main interpretation method
  public async interpret(program: Program): Promise<{ output: string, error?: string }> {
    try {
      this.output = [];
      await this.execute(program);
      return { output: this.output.join('\n') };
    } catch (error) {
      if (error instanceof Error) {
        return { output: this.output.join('\n'), error: error.message };
      }
      return { output: this.output.join('\n'), error: String(error) };
    }
  }

  // Execute a node in the AST
  private async execute(node: Node): Promise<any> {
    switch (node.type) {
      case NodeType.Program:
        return await this.executeProgram(node as Program);
      case NodeType.BlockStatement:
        return this.executeBlock((node as BlockStatement).body, new Environment(this.environment));
      case NodeType.ExpressionStatement:
        return await this.evaluate((node as ExpressionStatement).expression);
      case NodeType.IfStatement:
        return await this.executeIfStatement(node as IfStatement);
      case NodeType.WhileStatement:
        return await this.executeWhileStatement(node as WhileStatement);
      case NodeType.ForStatement:
        return await this.executeForStatement(node as ForStatement);
      case NodeType.ReturnStatement:
        return this.executeReturnStatement(node as ReturnStatement);
      case NodeType.FunctionDeclaration:
        return this.executeFunctionDeclaration(node as FunctionDeclaration);
      default:
        throw new Error(`Unknown node type: ${node.type}`);
    }
  }

  // Execute a program (top-level node)
  private async executeProgram(program: Program): Promise<void> {
    for (const statement of program.body) {
      await this.execute(statement);
    }
  }

  // Execute a block of statements
  public executeBlock(statements: Statement[], environment: Environment): void {
    const previous = this.environment;
    try {
      this.environment = environment;

      for (const statement of statements) {
        this.execute(statement);
      }
    } finally {
      this.environment = previous;
    }
  }

  // Execute an if statement
  private async executeIfStatement(stmt: IfStatement): Promise<void> {
    const condition = await this.evaluate(stmt.test);

    if (this.isTruthy(condition)) {
      await this.execute(stmt.consequent);
    } else if (stmt.alternate) {
      await this.execute(stmt.alternate);
    }
  }

  // Execute a while statement
  private async executeWhileStatement(stmt: WhileStatement): Promise<void> {
    while (this.isTruthy(await this.evaluate(stmt.test))) {
      await this.execute(stmt.body);
    }
  }

  // Execute a for statement
  private async executeForStatement(stmt: ForStatement): Promise<void> {
    const iterable = await this.evaluate(stmt.iterable);

    if (!Array.isArray(iterable)) {
      throw new Error('For loop iterable must be an array');
    }

    const previous = this.environment;
    try {
      this.environment = new Environment(this.environment);

      for (const value of iterable) {
        this.environment.define(stmt.variable, value);
        await this.execute(stmt.body);
      }
    } finally {
      this.environment = previous;
    }
  }

  // Execute a return statement
  private executeReturnStatement(stmt: ReturnStatement): void {
    let value = null;
    if (stmt.argument) {
      value = this.evaluate(stmt.argument);
    }

    throw new ReturnValue(value);
  }

  // Execute a function declaration
  private executeFunctionDeclaration(stmt: FunctionDeclaration): void {
    const func = new PashtoPlusPlusFunction(stmt, this.environment);
    this.environment.define(stmt.name, func);
  }

  // Evaluate an expression
  private async evaluate(expr: Expression): Promise<any> {
    switch (expr.type) {
      case NodeType.NumericLiteral:
        return (expr as NumericLiteral).value;
      case NodeType.StringLiteral:
        return (expr as StringLiteral).value;
      case NodeType.BooleanLiteral:
        return (expr as BooleanLiteral).value;
      case NodeType.ArrayLiteral:
        return await this.evaluateArrayLiteral(expr as ArrayLiteral);
      case NodeType.Identifier:
        return this.evaluateIdentifier(expr as Identifier);
      case NodeType.BinaryExpression:
        return await this.evaluateBinaryExpression(expr as BinaryExpression);
      case NodeType.AssignmentExpression:
        return await this.evaluateAssignmentExpression(expr as AssignmentExpression);
      case NodeType.CallExpression:
        return await this.evaluateCallExpression(expr as CallExpression);
      default:
        throw new Error(`Unknown expression type: ${expr.type}`);
    }
  }

  // Evaluate an array literal
  private async evaluateArrayLiteral(expr: ArrayLiteral): Promise<any[]> {
    const elements = [];
    for (const element of expr.elements) {
      elements.push(await this.evaluate(element));
    }
    return elements;
  }

  // Evaluate an identifier
  private evaluateIdentifier(expr: Identifier): any {
    if (this.environment.has(expr.name)) {
      return this.environment.get(expr.name);
    }
    throw new Error(`Line ${expr.line}: '${expr.name}' na shu! (not found)`);
  }

  // Evaluate a binary expression
  private async evaluateBinaryExpression(expr: BinaryExpression): Promise<any> {
    const left = await this.evaluate(expr.left);
    const right = await this.evaluate(expr.right);

    switch (expr.operator) {
      case '+':
      case 'jama':
        if (typeof left === 'number' && typeof right === 'number') {
          return left + right;
        }
        throw new Error(`Cannot add ${typeof left} and ${typeof right}`);
      case '-':
      case 'manfi':
        if (typeof left === 'number' && typeof right === 'number') {
          return left - right;
        }
        throw new Error(`Cannot subtract ${typeof right} from ${typeof left}`);
      case '*':
      case 'zarab':
        if (typeof left === 'number' && typeof right === 'number') {
          return left * right;
        }
        throw new Error(`Cannot multiply ${typeof left} and ${typeof right}`);
      case '/':
      case 'takseem':
        if (typeof left === 'number' && typeof right === 'number') {
          if (right === 0) {
            throw new Error('Division by zero');
          }
          return left / right;
        }
        throw new Error(`Cannot divide ${typeof left} by ${typeof right}`);
      case '%':
      case 'takseembaki':
        if (typeof left === 'number' && typeof right === 'number') {
          if (right === 0) {
            throw new Error('Modulo by zero');
          }
          return left % right;
        }
        throw new Error(`Cannot perform modulo on ${typeof left} and ${typeof right}`);
      case '_': // String concatenation
        return String(left) + String(right);
      case '==':
        return left === right;
      case '!=':
        return left !== right;
      case '>':
        if (typeof left === 'number' && typeof right === 'number') {
          return left > right;
        }
        throw new Error(`Cannot compare ${typeof left} and ${typeof right} with >`);
      case '<':
        if (typeof left === 'number' && typeof right === 'number') {
          return left < right;
        }
        throw new Error(`Cannot compare ${typeof left} and ${typeof right} with <`);
      case '>=':
        if (typeof left === 'number' && typeof right === 'number') {
          return left >= right;
        }
        throw new Error(`Cannot compare ${typeof left} and ${typeof right} with >=`);
      case '<=':
        if (typeof left === 'number' && typeof right === 'number') {
          return left <= right;
        }
        throw new Error(`Cannot compare ${typeof left} and ${typeof right} with <=`);
      default:
        throw new Error(`Unknown operator: ${expr.operator}`);
    }
  }

  // Evaluate an assignment expression
  private async evaluateAssignmentExpression(expr: AssignmentExpression): Promise<any> {
    const value = await this.evaluate(expr.right);

    // If the variable doesn't exist, define it
    if (!this.environment.has(expr.left.name)) {
      this.environment.define(expr.left.name, value);
    } else {
      this.environment.assign(expr.left.name, value);
    }

    return value;
  }

  // Evaluate a function call
  private async evaluateCallExpression(expr: CallExpression): Promise<any> {
    const callee = await this.evaluate(expr.callee);

    const args = [];
    for (const arg of expr.arguments) {
      args.push(await this.evaluate(arg));
    }

    if (typeof callee === 'function') {
      return await callee(...args);
    }

    if (callee instanceof PashtoPlusPlusFunction) {
      return callee.call(this, args);
    }

    throw new Error(`${expr.callee} is not a function`);
  }

  // Check if a value is truthy
  private isTruthy(value: any): boolean {
    if (value === null) return false;
    if (typeof value === 'boolean') return value;
    if (typeof value === 'number') return value !== 0;
    if (typeof value === 'string') return value !== '';
    if (Array.isArray(value)) return value.length > 0;
    return true;
  }
}

// Main entry point for running Pashto++ code
export async function runPashtoPlusPlus(
  code: string,
  inputCallback: () => Promise<string>
): Promise<{ output: string, error?: string }> {
  try {
    const { Lexer } = await import('./lexer');
    const { Parser } = await import('./parser');

    const lexer = new Lexer(code);
    const tokens = lexer.tokenize();

    const parser = new Parser(tokens);
    const program = parser.parse();

    const interpreter = new Interpreter(inputCallback);
    return await interpreter.interpret(program);
  } catch (error) {
    if (error instanceof Error) {
      return { output: '', error: error.message };
    }
    return { output: '', error: String(error) };
  }
}
